/**
 * \file hamming_sysfs.c
 * \brief Sysfs attribute definition
 *
 * This handles the creation and management of a kobject which reports
 * all relevant error information to userspace, as well as callbacks
 * to spin up, destroy, and manage configurations
 *
 * As a generic implementation, we define a circular buffer of errors up to
 * 32 entries long. An error is just a 64-bit addressible unit. Since there
 * is versatility in what the error actually is coming from, decoding the 
 * address depends on what the underlying device actually is.
 *
 * The sysfs interface for creating new disks will look something like this
 *
 * [BACKEND TYPE] [BACKEND PARAM] [FRONTEND TYPE] [FRONTEND PARAM]
 *
 * Backend type is an ASCII number representing the enumerated type, refer to
 * hamming_t for the proper type (and remember enumerated types are defined
 * in order, starting from zero)
 *
 * PARAM for BACK_BLOCK_IO would be the path you want to forward requests to
 * PARAM for BACK_BIN_TREE is the size of the tree you want generated
 *
 * PARAM for FRONT_BLOCK_IO is disregarded, any information you want
 * is calculated from backend information (or generated by the subsystem)
 * PARAM for FRONT_FRONTSWAP is disregarded, any information you want
 * is calculated form backend information (or generated by the subsystem)
 *
 * As this is space seperated, please no whitespace in paths
 */

#include <linux/sysfs.h>

#define HAMMING_ERROR_CIRCLE_LEN 32

static u8 cur_error;
static hamming_error_t errors[HAMMING_ERROR_CIRCLE_LEN];
static struct kobject *errors_obj; // NOTE: should formally bind error logging to disks

/**
 * \brief Report all error information to userspace
 *
 * \param[in] kobj		Kobject
 * \param[in] attr		Kobject attribute
 * \param[out] buf		Length of buffer to parse on input
 *
 * \return Negative on failure, length of errors otherwise
 */
static ssize_t hamming_sysfs_error_show(struct kobject *kobj, struct kobj_attribute *attr, char *buf){
    int i;
    for(i = 0;i < HAMMING_ERROR_CIRCLE_LEN;i++){
        if(errors[i].time_micro_s){
            memcpy(buf + sizeof(hamming_error_t)*i, errors + i, sizeof(hamming_error_t));
        }else break;
    }
    return i * sizeof(hamming_error_t);
}

/**
 * \brief Universal disk management sysfs interface
 *
 * \param[in] kobj		Kobject
 * \param[in] attr		Kobject attribute
 * \param[in] buf		Buffer to parse
 * \param[in] count		Length of buffer to parse
 */
static ssize_t hamming_sysfs_disk_mgmt(struct kobject *kobj, struct kobj_attribute *attr, char *buf, size_t count){
    int i;
    int backend, frontend;
    char back_attr[512], front_attr[512];

    if(count > 512){
        return -EINVAL;
    }
    
    memset(back_attr, 0, 512);
    memset(front_attr, 0, 512);
    sscanf(buf, "%d %s %d %s", &backend, back_attr, &frontend, front_attr);

    if(backend >= 2 || frontend >= 2){
        return -EINVAL;
    }

    // TODO: actually spin up a new Hamming device
}

static struct kobj_attribute hamming_sysfs_error_attribute =
    __ATTR(error_cycle, S_IRUGO, hamming_sysfs_error_show, NULL);
static struct kobj_attribute hamming_sysfs_disk_mgmt =
    __ATTR(disk_mgmt, S_IWUSR | S_IWGRP, NULL, hamming_sysfs_disk_mgmt);

static struct attribute *attrs[] = {
    &hamming_sysfs_error_attribute.attr,
    &hamming_sysfs_disk_mgmt.attr,
    NULL
};

static struct attribute_group attr_group = {
    .attrs = attrs
};

/**
 * \brief Initialize sysfs
 *
 * The only output is currently a error circular buffer, which is written to the sysfs in
 * whatever the current order is upon request
 *
 * \return Negative on error, zero otherwise
 */
static int hamming_sysfs_init_error(void){
    int ret;
    errors_obj = kobject_create_and_add("hamming", kernel_kobj);
    if(errors_obj == NULL){
        return -ENOMEM;
    }
    
    ret = sysfs_create_group(errors_obj, &attr_group);
    if(ret){
        kobject_put(errors_obj);
        return ret;
    }
    return 0;
}

/**
 * \brief Close sysfs
 *
 * Remove any groups and free kobjects associated with lifetime of driver.
 *
 * NOTE: this actually breaks really badly if you don't do this
 *
 * \return Negative on error, zero otherwise
 */
static int hamming_sysfs_close_error(void){
    sysfs_remove_group(errors_obj, &attr_group);
    kobject_put(errors_obj);
    return 0;
}

/**
 * \brief Register an error with the sysfs interface
 *
 * Logs the current time in microseconds, as received from do_gettimeofday (kernelspace
 * equivalent of gettimeofday). Address field is custom defined by whatever reported it, so
 * this doesn't scale that well. All error reporting is done through here to make it simple.
 *
 * NOTE: does do_gettimeofday define constant advancement (i.e. leap seconds/time zone shifts?)
 *
 * \param[in] addr		Address of last SEU
 *
 * \return Zero
 */
static int hamming_sysfs_reg_error(u64 addr){
    struct timeval tv;
    do_gettimeofday(&tv);
    errors[cur_error].addr = addr;
    errors[cur_error].time_micro_s = (tv.tv_sec*1000000) + tv.tv_usec;

    cur_error++;
    if(cur_error == HAMMING_ERROR_CIRCLE_LEN){
        cur_error = 0;
    }
    return 0;
}
